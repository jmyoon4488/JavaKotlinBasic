package middlelevel.Study_14_Lambda

/*
1. Lambda Expression (람다 표현식) : 함수형 프로그래밍 언어이며, 코드의 간결함을 주목적으로 합니다. (함수 축약형)

- 일반 함수 형식
fun `함수이름`(`매개변수`) { `실행코드` }

- 람다 표현식 = 일반 함수의 축약형
{ `매개변수` -> `실행코드` } // 실행코드 마지막줄이 return 됨

- 람다 함수의 규칙
  1. 람다 함수는 항상 {} 블록으로 감싸서 표현해야 합니다.
  2. {} 안에서는 -> 연산자가 반드시 있어야 합니다. (매개변수가 없을때는 -> 가 생략됩니다.)
  3. -> 연산자 왼쪽은 매개변수, 오른쪽은 실행코드
  4. 매개변수 타입을 선언해야 합니다. (단, 추론할 수 있을 때는 생략 가능)
  5. 함수의 반환값은 실행코드에서 제일 마지막줄이 return 됩니다.
  6. 람다식의 실행코드가 여러줄일때는 그냥 줄바꿈해서 사용하면 됩니다.

- 매개변수가 없는 람다함수
val sum = { -> 100 + 50 }
  - 이 경우는 매개변수가 없기 때문에 -> 를 생략할 수 있습니다.

- 예시
  - 일반 함수
fun sum(a: Int, b: Int) : Int  {
    return a + b
}

  - 람다식
val sum = { a: Int, b: Int -> a + b }

- 함수형 프로그래밍은 장점이 많습니다. 유지보수도 괜찮고...

- 람다식은 익명함수라서 일반적으로는 호출할 수 없습니다.
  - 주로 변수에 담아서 사용하게 됩니다.
  - 변수를 사용하지 않고 함수를 호출 하기 위해서는 람다식 블록 뒤에 바로 () 를 붙여줍니다. // 왜 안되지..?
    - 단 이 방식을 사용하려면 해당 람다식 바로 이전 코드 끝을 세미콜론(;) 으로 마쳐야 합니다.
  - 또는, run { `람다식` } 으로 작성하게 되면 해당 코드 타이밍에 바로 람다식이 실행됩니다.

- 함수 타입 선언
  - typealias 키워드를 이용한 타입 정의
```
typealias MyType = (Int) -> Boolean
val myFunc: MyType = { it > 10 }  // 여기서 it 는 매개변수
```

  - it 는 매개변수가 하나일 때 별도의 매개변수를 선언하지 않고 사용할 수 있는 미리 지정된 예약어 입니다.
```
val lambdaFun: (Int) -> Int = { x -> x + 10 }
val lambdaFun: (Int) -> Int = { it + 10 }  // 위와 동일
```

  - it 은 타입이 정의 되어있는 곳에서만 사용할 수 있습니다.
```
val lambdaFunc = { it * 10 } // error 타입을 알 수 없어서...
```

- 익명함수를 이용한 함수 전달

- 함수 형식 구분
  1. 일반 함수
  2. 익명 함수
  3. 람다 함수
  - 일반함수 축약 -> 익명함수 / 익명함수 축약 -> 람다함수

* */

class Lambda {
}

fun main() {
    // 람다식 사용법
    val result = sumLambda(3, 5);
    println(result)
    // =======================================================================================================================

    run { println("람다 바로 실행 1") };

    { println("람다 바로 실행 2") }()  // 바로 전 코드 끝을 세미콜론(;) 으로 끝마쳐야 합니다.
//    { println("람다 바로 실행 3") }()  // 이전 코드가 세미콜론으로 안끝나서 error
    // =======================================================================================================================

    // 함수 반환
     val opFun = op("+")  // 결과 반환이 함수이므로 opFun 도 결국 변수처럼 보이지만 함수입니다.
    println("result : ${opFun(4, 5)}")
    // =======================================================================================================================

    // 함수참조연산자
    // 일반 람다함수일때
    cc { it * 100 }
    // 함수참조 - 람다 실행부분을 그냥 일반 함수로 생성 후
    fun ccFun(x: Int) : Int {
        return x * 100
    }
    cc(::ccFun) // 함수 참조를 이용해 위 람다를 사용한 것과 같은 결과를 얻을 수 있습니다.
    // 함수참조에 사용되는 함수의 매개변수와 반환값 형태가 고차함수의 매개함수 위치에 들어갈 형태와 동일해야 합니다.
    // =======================================================================================================================
    // 익명함수를 이용한 함수 전달
    val lambdaFunc = { x: Int ->
        println("lambda in")
        // return x * 100   // error - 람다함수에서는 return 을 사용할 수 없습니다.
        // return 을 사용하지 못하기 때문에 반환 타입도 명시할 수 없습니다.
        // 마지막 표현식을 자동으로 추론해서 return 하게 됩니다.
        x * 100             // lambda 의 return 부분
    }
    println("lambdaFunc : ${lambdaFunc(4)}")

    // 익명함수의 경우에는...
    val anonymousFunc1 = fun(a: Int) : Int = a * 100
    val anonymousFunc2 = fun(a: Int) : Int {
        println("anonymousFunc2")
        return a * 200      // 익명함수는 람다와 다르게 return 을 사용할 수 있습니다.
    }
    println("anonymousFunc2 : ${anonymousFunc2(3)}")

    // =======================================================================================================================
    // 익명함수를 고차함수에서 사용하는 방법
    fun aa(a: (Int) -> Int) {
        println("aa : ${a(100)}")
    }
    // 람다보다는 코드가 간결하지 못하지만 익명함수를 사용할 수 있습니다.
    aa(fun(x: Int) : Int = x * 9)

    aa(fun(x: Int) : Int {
        println("anonymous")
        return x * 10       // 익명 함수이기 때문에 return 을 사용할 수 있고 return 타입도 쉽게 정할 수 있습니다.
    })

    // =======================================================================================================================

    // =======================================================================================================================
}

// 일반 함수
fun sumFunc(a: Int, b: Int) : Int  {
    return a + b
}

// 람다식
val sumLambda = { a: Int, b: Int -> a + b }

// 람다식 구성  (입력 매개변수 타입) -> 반환타입 = { 매개변수 -> 실행코드 }
val lambdaFun: (Int) -> Int = { x: Int -> x * 2 }

// 고차함수의 반환
fun op(str: String) : (x: Int, y: Int) -> Int {
    when (str) {
        "+" -> return { x, y -> x + y }
        "-" -> return { x, y -> x - y }
        "*" -> return { x, y -> x * y }
        "/" -> return { x, y -> x / y }
        else -> return { x, y -> x % y }
    }
}

// 함수참조연산자 예제
fun cc(funParam: (x: Int) -> Int) {
    println("funParam : ${funParam(100)}")
}

class Student() {
    var name: String? = null
    var age: Int? = null

    fun speak() {
        println("hi $name")
    }

    fun getInfo() {
        println("name : $name , age : $age")
    }
}